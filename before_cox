## 
processed_list_bckp <- processed_list

processed_list <- processed_list %>%
  map(~ clean_sex(.x))


processed_list <- processed_list %>%
  map(~ .x %>%
        assign_anthro_scores() %>%
        assign_anthroplus_scores() %>%
        clean_zscores() %>%
        classify_bmi_category() %>%
        classify_central_obesity() %>%
        classify_stunting() 
  )














library(dplyr)
library(rlang)

build_surv_tv <- function(df, virus_var) {
  virus_sym <- sym(virus_var)
  
  # 1. Compute event_age and censor_age per child
  event_info <- df %>%
    arrange(h_id_int, age) %>%
    group_by(h_id_int) %>%
    summarise(
      first_age    = first(age),
      event_age    = {
        ages <- age[ (!!virus_sym) == 1 & !is.na(!!virus_sym) ]
        if (length(ages) > 0) min(ages) else NA_real_
      },
      censor_age   = {
        ages <- age[ !is.na(!!virus_sym) ]
        if (length(ages) > 0) max(ages) else NA_real_
      },
      baseline_sero = first(!!virus_sym),
      .groups = "drop"
    ) %>%
    # keep only children who are seronegative at first observation
    filter(baseline_sero == 0, !is.na(censor_age))
  
  # 2. Restrict df to eligible children
  df_elig <- df %>%
    inner_join(event_info, by = "h_id_int")
  
  # 3. Build time intervals per child
  tv_df <- df_elig %>%
    arrange(h_id_int, age) %>%
    group_by(h_id_int) %>%
    mutate(
      tstart   = age,
      tstop_raw = lead(age),
      # last interval ends at censor_age
      tstop_raw = if_else(is.na(tstop_raw), censor_age, tstop_raw),
      # truncate at censor age
      tstop = pmin(tstop_raw, censor_age),
      # event occurs in the interval that contains event_age
      event = as.integer(!is.na(event_age) &
                           event_age >= tstart &
                           event_age < tstop)
    ) %>%
    ungroup() %>%
    # keep only proper intervals
    filter(tstop > tstart)
  
  tv_df
}




pool_bmi_effect <- function(fit_list, coef_name = "bmi_scaled") {
  M <- length(fit_list)
  
  # extract coefficients
  betas <- sapply(fit_list, function(fit) {
    coef(fit)[coef_name]
  })
  
  # extract variances
  vars <- sapply(fit_list, function(fit) {
    vcov(fit)[coef_name, coef_name]
  })
  
  # Rubin pooling
  q_bar <- mean(betas)                # pooled beta
  W     <- mean(vars)                 # within-imputation variance
  B     <- var(betas)                 # between-imputation variance
  T_var <- W + (1 + 1 / M) * B        # total variance
  
  se <- sqrt(T_var)
  HR <- exp(q_bar)
  CI <- exp(q_bar + c(-1, 1) * 1.96 * se)
  
  list(
    beta = q_bar,
    se   = se,
    HR   = HR,
    CI   = CI
  )
}





library(purrr)
library(dplyr)
library(survival)

virus_vars <- c(
  "CMV_class_sero",
  "EBV_class_sero",
  "cut_Avd36_sero",
  "cut_VZV_sero",
  "cut_BK_sero",
  "cut_JC_sero",
  "cut_KI_sero",
  "cut_WU_sero",
  "cut_MCV_sero"
)

run_cox_for_virus <- function(virus) {
  # build time-varying data for each imputed dataset
  surv_list <- processed_list %>%
    imap(~ {
      df_tv <- build_surv_tv(.x, virus_var = virus)
      df_tv$.imp <- .y
      df_tv
    })
  
  # if some imputations have zero eligible data, drop them
  surv_list <- surv_list[lengths(surv_list) > 0]
  if (length(surv_list) == 0) {
    return(tibble(
      virus = virus,
      beta  = NA_real_,
      se    = NA_real_,
      HR    = NA_real_,
      CI_low  = NA_real_,
      CI_high = NA_real_
    ))
  }
  
  # fit Cox in each imputation
  cox_formula_min_tv <- Surv(tstart, tstop, event) ~
    bmi_scaled + sex + factor(coh)
  
  fit_list <- lapply(surv_list, function(dat) {
    coxph(cox_formula_min_tv, data = dat)
  })
  
  pooled <- pool_bmi_effect(fit_list, coef_name = "bmi_scaled")
  
  tibble(
    virus   = virus,
    beta    = pooled$beta,
    se      = pooled$se,
    HR      = pooled$HR,
    CI_low  = pooled$CI[1],
    CI_high = pooled$CI[2]
  )
}

pooled_all <- map_dfr(virus_vars, run_cox_for_virus)
pooled_all
































